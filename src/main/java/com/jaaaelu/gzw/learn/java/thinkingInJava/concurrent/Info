第二十一章 并发

1.并行编程可以使程序执行速度得到极大提高，或者为设计某些类型的程序提供更易用的模型，或者两者都有。
2.当并发执行的任务彼此开始产生相互干涉时，实际的并发问题就会接踵而至。
3.用并发解决的问题大体上可以分为"速度"和"设计可管理性"两种。
4.并发通常是提高运行在单处理器上的程序的性能。
如果某些原因导致程序阻塞之后，在没有并发的情况下，则导致整个程序都将停止下来，而有了并发之后，当一任务阻塞之后，程序中的其他任务还可以继续执
行。
从性能上，如果没有任务会阻塞，那么在单处理器机器上使用并发就没有任何意义。
5.进程是运行在它自己的地址空间内的自包容的程序。
6.与多任务操作系统中分叉外部进程不同，线程机制是由执行程序表示的单一进程中创建的任务（Java 中）。
7.Java 的线程机制是抢占式的，这表示调度机制会周期性的中断线程，将上下文切换到另一个多线程。
8.通过使用多线程机制，这些独立任务（也被称为子任务）中的每一个都将由执行线程来驱动。一个线程就是在进程中的一个单一的顺序控制流，因此，单个进
程可以拥有多个并发执行的任务，但是你的程序是的每个任务都好像有其自己的 CPU 一样。其底层机制是切分 CPU 时间，但通常你不需要考虑它。
9.Thread.yield() 的调用是对线程调度器（Java 线程的一种机制，可以将 CPU 从一个线程移给另一个线程）的一种建议，它在声明："我已经执行完生命
周期中最重要的部分了，此刻真是切换给其他任务执行一段时间的大好时机。"（不过这只是一个暗示，没有任何机制保证它将会被采纳）。
10.Executor 允许你管理异步任务的执行，而无需显式的管理线程的生命周期。
对 shutDown() 方法的调用可以终止新任务被提交给这个 Executor，当前线程将继续运行在 shutDown() 被调用之前提交的所有任务。这个程序将在 Executor
中的所有人任务完成之后尽快退出。
11.Runnable 是执行工作的独立任务，但是它不返回任何值。如果你希望任务在完成时能够返回一个值，那么可实现 Callable 接口不是 Runnable 接口。
12.睡眠使得线程调度器可以切换到另一个线程，进而驱动另一个任务。
13.线程的优先级将该线程的重要性传递给了调度器。尽管 CPU 处理现有线程集的顺序是不确定的，但是调度器将倾向于让优先权最高的线程执行。然而，这并
不意味着优先权较低的线程将得不到执行（也就是说，优先权不会导致死锁）。优先权较低的线程仅仅是执行的频率较低。
14.所谓后台线程，是指在程序运行的时候在后台提供一种通用的服务的线程，并且这种线程并不属于程序的不可或缺的部分。因此，当所有的非后台线程结束时，
程序也就终止了，同时会杀死进程中的所有后台线程。反过来说，只要有任何非后台线程还在运行，程序就不会终止。
必须在线程启动之前调用 setDaemon() 方法，才能把它设置为后台线程。
15.Java 的线程机制基于来自 C 的低级的 p 线程方式。
16.一个线程可以在其他线程之上调用 join() 方法，其效果是等待一段时间直到第二个线程结束才继续执行。如果某一个线程在另一个线程 t 上调用 t.join()，
此线程将被挂起，直到目标线程 t 结束才回复（即 t.isAlive() 返回 false）。
17.一旦异常逃出任务的 run() 方法，它就会向外传播到控制台，除非你采取特殊的步骤捕获这种错误异常。也就是使用过 Thread.UncaughtExceptionHandler
接口与自定义的线程工厂配合，这样就能在线程执行时捕获到它。
18.对于并发工作，你需要某种方式来防止两个任务访问相同的资源，至少在关节阶段不能出现这种情况。防止这种冲突的方法就是当资源被一个任务使用时，在
其上加锁。第一个访问某项资源的任务必须锁定这项资源，使其他任务在其被解锁之前，就无法访问它，而在其被解锁之时，另一个任务就可以锁定并使用它，
以此类推。
19.所有对象都自动含有单一的锁（也称为监视器）。当在对象上调用任意 synchronized 方法的时候，此对象都被加锁，这是该对象上的其他 synchronized
方法只能等到前一个方法调用完毕并释放了锁之后才能对调用。对于下面的方法，如果某个任务对对象调用了 f()，对于同一个对象而言，就只能等到 f() 调
用就是并释放了锁之后，其他任务才能调用 f() 和 g()。
synchronized void f() {};
synchronized void g() {};
所以，对于某个特定对象来说，其所有 synchronized 方法共享一把锁，这可以被用来防止多个任务同时访问被编码对象的内存。
20.一个任务可以多次获得对象的锁。显然，只有首先获得了锁的任务才能允许继续获得多个锁。每当任务离开一个 synchronized 方法，计数递减（首先是
进入 synchronized 方法计数递增），当计数为 0 的时候，锁被完全释放，此时别的任务就可以使用此任务了。
21.针对每个类，也有一个锁（作为类的 Class 对象的一部分），所以 synchronized static 方法可以在类的范围内防止对 static 数据的并发访问。
22.你应该什么时候同步呢？
答：如果你正在写一个变量， 它可能接下来会被另一个线程读取，或者正在读取一个上一次以及被另一个线程写过的变量，那么你必须使用同步，并且，读写线
程都必须都是用相同的监视器锁同步。
如果在你的类中有超过一个方法在处理临界数据，那么你必须同步所有相关的方法。
23.除了 synchronized 关键字之外，我们可以使用显式的 Lock 对象，Lock 对象必须被显式地创建、锁定和释放。
24.原子操作是不能被线程调度机制中断的操作；一旦操作开始，那么它一定可以在可能发生的"上下文切换"之前（切换到其他线程）执行完毕。
25.如果使用 volatile 关键字 ，就会获得原子性。volatile 关键字还确保了应该用中的可视性。如果你将一个域声明为 volatile 的，那么只要对这个
域产生了写操作，那么所有的读操作就可以看到这个修改。
26.Java 在 Java5 中引入了相关的原子类。
27.有时，你只希望防止多个线程同时访问方法内壁怒的部分代码，而不是防止访问整个方法。通过这种方式分离出来的代码段被称为临界区，它也使用 synchronized
关键字建立。例如：
synchronized (syncObject) {
    ...
}
这也被成为同步控制块；在进入此代码前，必须得到 syncObject 对象的锁，如果其他线程以及获得这个锁，那么就得等到锁被释放后，才能进入临界区。
synchronized 块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象 synchronized(this)，在这种方式中，如
果获得了 synchronized 块上的锁，那么该对象其他的 synchronized 方法和临界区就不能被调用了。因此，如果在 this 上同步，临界区的效果就会直
接缩小在同步的范围内。
有时必须在另一个对象上同步，大师如果你要这么做，就必须确保所有相关的任务都在同一个对象上同步。
也可以使用显式 Lock 对象来创建临界区。
28.synchronized 不属于方法特征签名的组成部分。
29.防止任务在共享资源上产生冲突的第二个方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用想用变量非每个线程都创建不同的存储。因
此如果你有 5 个线程都要使用变量 x 的说表示的对象，那线程本次存储就会生成 5 个用于 x 的不同存储块。主要是：它们使得你可以将状态与线程关联起
来。
创建和管理本地存储可以有 ThreadLocal 来实现。
ThreadLocal 对象通常当作静态域存储。
30.线程的四种状态：
 - 新建（new）：当线程被创建时，它只会短暂的处于这个状态。此时它以及分配了必需的系统资源，并执行了初始化。此刻线程已经有资格获得 CPU 时间了，
 之后调度器分将把这个线程转变为可运行的状态或阻塞状态。
 - 就绪（runnable）：在这个状态下，只要调度器把配时间片分配给线程，线程就可以运行。也就是说，在任意时刻，线程可以运行也可以不运行。只要调度
 器分配时间片给线程，它就运行；这不同于死亡和阻塞状态。
 - 阻塞（blocked）：线程能够运行，但是某个条件阻止它的运行。当线程处于阻塞状态时，调度器将忽略线程，不会分配给线程任何 CPU 时间。直到线程重
 新进入就绪状态，它才能只能操作。
 - 死亡（dead）：处于死亡或终止状态的线程将不再是可调度的，并且再也不会得到 CPU 时间，它的任务已结束，或不再是可运行的。任务死亡的通常方式
 是从 run() 方法返回，但是任务的线程还可以被中断，你将要看到这一点。
31.一个任务进入阻塞状态，可能有如下原因：
 - 通过调用 sleep() 是任务进入休眠状态，这种情况下，任务在指定的时间内不会运行。
 - 通过调用 wait() 使线程挂起。直到程序得到 notify() 或 notifyAll() 消息，线程才会进入就绪状态。
 - 任务在等待某个输入或输出完成。
 - 任务试图在某个对象上调用其同步控制方式。但对象锁不可用，因为另一个任务已经获取了这个锁。
32.Thread 类包含 interrupt() 方法，因此你可以终止被阻塞的任务，这个方法将设置线程的中断状态。如果一个线程已经被阻塞，或者试图执行一个阻塞
操作，那么设置这个线程的中断状态将抛出 InterruptException。
33.wait() 使你可以等待某个条件发生变化，而改变这个条件超出了当前方法的控制能力。通常，这种条件将由另一个任务来改变。因此 wait() 会在等待外
部世界产生变化时候将任务怪气，并且只有在 notify() 或 notifyAll() 发生时，即表示发生了某些感兴趣的十五，这个任务才会被唤醒并去检查所产生的
变化。因此，wait() 提供了一种在任务之间对活动同步的方式。
当你调用 wait() 时，就是在声明："我已经刚刚做完能做的事情，因此我要在这里等待，但是我希望其他的 synchronized 操作在条件适合的情况下能够执
行"。
34.调用 sleep() 的时候锁并没有被释放，调用 yield() 也属于这种情况。
另一方面，当一个任务在方法里遇到了对 wait() 的调用的时候，线程的追星被挂起，对象上的锁被释放。
但是与 sleep() 不同的是，对于 wait() 而言：
 - 在 wait() 期间对象锁是释放的。
 - 可以通过 notify()、notifyAll()，或者令时间到期，从 wait() 中恢复执行。
实际上，只能在同步控制方法或同步控制块里调用 wait()、notify() 和 notifyAll()。
因为不操作锁，所以 sleep() 可以在非同步控制方法里调用。
也就是说，要先有锁才能对锁就行操作，比如释放。
所以，调用 wait()、notify() 和 notifyAll() 的任务在调用这些方法之前必须"拥有"（获取）对象的锁。
35.书中 P706 页，错失的信号这个例子说明了，如果有 wait() 这种操作，是通过判断语音进行判断执行的，那么该判断语句应在 synchronized 同步块
之内，而不是在同步块之外，这样就避免了进入同步块之后判断条件发生变化，从而错误进入 wait() 调用，导致死锁，代码如下：
T1:
    synchronized(lockObject) {
        //  ... 表示为 T2 设置条件
        //  是防止 T2 调用 wait() 的一个动作，当前前提是 T2 还没有调用 wait()
        ...
        lockObject.notify();
    }

T2:
    //  正确写法
    synchronized(lockObject) {
        while(某个条件) {
            lockObject.wait();
        }
    }

    //  错误写法
    while(某个条件) {
        synchronized(lockObject) {
            lockObject.wait();
        }
    }
36.使用 notify() 而不是 notifyAll() 是一种优化。使用 notify() 时，在众多等待同一个锁的任务中只有一个被唤醒，因此如果你希望使用 notify()，
就必须保证被唤醒是恰当的任务。另外，为了使用 notify()，所有任务必须等待相同的条件，因为如果你有多个任务在等待不同的条件，那么你就不会知道是
否唤醒了恰当的任务。如果使用 notify()，当条件发生变化时，必须只有一个任务能够从中受益。最后，这些限制对所有可能存在的子类也必须总是起作用。
如果这些规则中有任何一条不满足，那么你就必须使用 notifyAll() 而不是 notify()。
37.notifyAll() 意思将唤醒"所有正在等待的任务"，但情况并非如此————事实上，当 notifyAll() 因某个特定锁而被调用时，只有等待这个锁的任务才
会被唤醒。也就是说，只会唤醒所有与 notifyAll() 对应的那个锁的所有 wait() 任务。
38.Condition 中的 await()、signal() 和 signalAll() 是与显式 Lock 一起配合使用的，与 synchronized 配合 wait()、notify() 和 notifyAll()
效果一样。
与 notifyAll() 相比 signalAll() 是更安全的方式。
每个 lock() 的到调用都必须紧跟一个 try-finally 自居，用来保证在所有情况下都可以释放锁。
而调用 await()、signal() 和 signalAll() 之前也必须先拥有锁。
39.同步队列也是一个不错的任务同步选择。
40.任务可以编程阻塞状态，所以就可能出现这种情况：某个任务在等待另一个任务，而后者又在等待别的任务，这样一只下去，直到这个链条上的任务又在等待
第一个任务释放锁。这得到了一个任务之间互相等待的连续循环，没有哪个线程能继续。这被称之为死锁。
41.当以下四个条件同时满足时，就会发生死锁：
 - 互斥条件。任务使用的资源中至少有一个是不能共享的。
 - 至少又一个你任务它必须持有一个资源且正在等待获取另一个当前被别的任务持有的资源。
 - 资源不能被任务抢占，任务必须把资源释放当作普通事件。
 - 必须有循环等待，这时，一个任务等待其他任务所持有的资源，后者又在等待另一个任务所持有的资源，这样一直下去，直到又一个任务在等待第一个任务所
 持有的资源，使得大家都被锁住。
只要破坏其中一个条件就不会导致死锁，而破坏最后一个也是最容易的一个。
42.只互斥那些你绝对必须互斥的部分。
43.ReadWriteLock 对向数据结构相对不频繁的写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock 使得你可以同时有
多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直到这个写锁被释放。