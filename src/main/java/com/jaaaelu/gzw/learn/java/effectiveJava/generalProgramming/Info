第八章 通用程序设计

1.第四十五条：将局部变量的作用域最小化。

要使局部变量的作用域最小化，最有力的方法就是在第一次使用它的地方声明。

几乎每个局部变量的声明都应该包含一个初始化表达式。
如果你还没有足够的信息来对一个变量进行有意义的初始化，就应该推迟这个声明，直到可以初始化为止。

最后一种"将局部变量的作用域最小化"的方法是使方法小而集中。



2.第四十六条：for-each 循环优先于传统的 for 循环。

利用 for-each 循环不会有性能损失，甚至用于数组也一样。

有三种常见的情况无法使用 for-each 循环：
 - 过滤：如果需要遍历集合，并删除选定的元素，就需要显式使用迭代器，以便可以调用它的 remove 方法；
 - 转换：如果需要遍历列表或者数组，并取代它部分或者全部的元素值，就需要列表迭代器或者数组索引，以便设置元素的值；
 - 平行地带：如果需要并行的遍历多个集合，就需要显式的控制迭代器或者索引变量，以便所有迭代器或者索引变量都可以得到同步前移；



3.第四十七条：了解和使用类库。

通过使用标准类库，可以充分利用这些编写标准类库的专家的知识，以及在你之前的其他人的使用经验。



4.第四十八条：如果需要精确的答案，请避免使用 float 和 double。

使用 BigDecimal 类型代替 double。



5.第四十九条：基本类型由于装箱基本类型。

在基本类型和装箱基本类型之间有三个主要区别：
 - 基本类型只有值，而装箱基本类型则具有和它们的值不一样的同一性；
 换句话说，装箱基本类型可以具有相同的值和不同的同一性。
 - 基本类型只有功能完备的值，而每个装箱基本类型除了它对应的基本类型所有功能之外，还有个非功能值：null；
 - 基本类型通常比装箱基本类型更节省时间和空间；

几乎在任何一种情况下，当在一项操作中混合使用基本类型和装箱基本类型时，装箱基本类型就会自动拆箱，这种情况无一例外。
如果 null 被自动拆箱，就会得到一个空指针异常。

那么什么时候应该使用装箱基本类型呢？
 - 作为集合中的元素、键和值；
 - 参数化类型中，必须使用装箱基本类型作为类型参数，因为 Java 不允许使用基本类型；
 - 在进行反射的方法调用时，必须使用装箱基本类型；



6.第五十条：如果其他类型更合适，则尽量避免使用字符串。

字符串不适合代替其他的值类型。
字符串不适合代替枚举类型。
字符串不合适代替聚集类型。
字符串也不适合代替能力表。

若使用不当，字符串会比其他的类型更加笨拙、更不灵活、速度更慢、也更容易出错。



7.第五十一条：当心字符串连接的性能。

字符串连接操作符是把多个字符串合并为一个字符串的便利途径。

为连接 n 个字符串而重复的使用字符串连接操作符，需要 n 的平方级的时间。
这是由字符串不可变而导致的不行结果。
当两个字符串被连接在一起时，它们的内容都要被拷贝。

为了获得可以接受的性能，请使用 StringBuilder 替代 String。



8.第五十二条：通过接口引用对象。

优先使用接口而不是类来引用对象。
如果由合适的接口类型存在，那么对于参数、返回值、变量和域来说，就都应供使用接口类型进行声明。

如果你养成了用接口作为类型的习惯，你的程序将会更灵活。

如果没有合适的接口存在，完全可以使用类而不是接口来引用对象。



9.第五十三条：接口优先于反射机制。

核心反射机制提供了"通过程序来访问关于已装载的类的信息"的能力。

反射机制允许一个类使用另一个类，即使当前者被编译的时候后者还根本不存在的时候。
然而，这种能力也要付出代价：
 - 丧失了编译时类型检查的好处，包括异常检查；
 - 执行反射访问所需要的代码非常笨拙和冗长；
 - 性能损失；

通常，普通应用程序在运行时不应该以反射方式访问对象。
如果只是由非常有限的形式使用反射机制，虽然也要付出少许代价，但是可以获得许多好处。

类对应在运行时可能不存在的其他类、方法或者域的依赖性，用反射法进行管理，这种用法是合理的，但是很少使用。

10.第五十四条：谨慎的使用本地方法。

JNI 用于 Java 应用程序可以调用本地方法，所谓本地方法就是指本地程序设计语言（比如 c 或者 c++）来编写的特殊方法。

从历史上看，本地方法主要由三种用途：
 - 提供饿了"访问特定于平台的机制"的能力；
 - 提供了访问遗留代码库的能力；
 - 以及编写应用中注重性能的部分，以提高系统的性能；

使用本地方法来提高性能的做法不值得提倡。
在早期的发行版本中，这样做往往是很有必要的，但是 JVM 实现变得越来越快了。

11.第五十五条：谨慎的进行优化。

优化的弊大于利，特别是不成熟的优化。

不要因为性能而牺牲合理的结构。
要努力编写好的程序而不是快的程序。

好的程序体现了信息隐藏的原则：只要有可能，它们就会把设计决策集中在单个模块中，因此可以该拜年单个决策，而不会影响到系统的其他部分。

努力避免哪些限制性能的设计决策。

当一个系统设计完成之后，其中最难以更改的组件是那些制定了模块之间交互关系以及模块于外界交互关系的组件。

要考虑 API 设计决策的性能后果。
为了获得好的细嫩而对 API 进行包装，这是一种非常不好的想法。

在每次试图做优化之前和之后，要对性能进行测量。

总而言之，不要费力去编写看快速的程序——应该努力编写好的程序，速度自然会随之而来。



12.第五十六条：遵守普遍接受的命名规范。

