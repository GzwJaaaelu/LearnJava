第三章 对所有对象都通用的方法

1.第八条：覆盖 equals 时请遵守通用约定。

如果满足了以下任何一个条件，这就是正式所期望的结果：
 - 类的每个实例本质上是唯一的。
 - 不关心类是否提供了"逻辑相等"的测试功能。
 - 超类已经覆盖了 equals，从超类继承过来的行为对与子类也是合适的。
 - 类是私有或是包级私有的，可以确定它的 equals 方法永运不会被调用。

什么是否应该覆盖 Object.equals 呢？
 - 如果类具有自己特有的"逻辑相等"概念（不同于对象等同的概念），而且超类还没有覆盖 equals 以实现期望的行为，这是我们就需要覆盖 equals 方法。
 通常是"值类"的情形，如 Integer、String 或 Date 之类。不过如是单例或枚举就的"值类"就不用进行覆盖了。

下面是覆盖 equals 方法时的约定，来自 Object 的规范：
 - 自反性：对于任何非 null 的引用值 x，x.equals(x) 必须返回 true。
    第一个要求仅仅说明说明对象必须等于其自身。
 - 对称性：对于任何非 null 的引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 必须返回 true。
    第二个要求是说，任何两个对象对于"它们是否相等"的问题必须保持一致。
 - 传递性：对于任何非 null 的引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 也返回 true，那么 x.equals(z) 也必须返
 回 true。
    第三个要求时，如果一个对象等于第二个对象，并且第二个对象又等于第三个对象，则第一个对象一定等于第三个对象。
 - 一致性：对于任何非 null 的引用值 x 和 y，只要 equals 的比较操作在对象中的 所有信息没有被修改，多次调用 x.equals(y) 就会一致返回 true，
 或者一致返回 false。
    第四个要求是，如果两个对象相等，他们就必须始终保持相等，除非它们中的一个对象（或者两个都）被修改了。
 - 非空性：对于任何非 null 的引用值 x，对于 x.equals(null) 必须返回 false。
    最后一个要求是，指所有的对象都必须不等于 null。

综上所述，得出实现高质量 equals 方法的诀窍：
 1.使用 == 操作符检查"参数是否为这个对象的引用"。
 2.使用 instanceof 操作符检查"参数是否为正确的类型"。
 3.把刹那好书转换成正确的类型。
 4.对于该类中的每个"关键"域，检查参数重的域是否与该对象中对应的域相匹配。
  - 对于不是 float 和 double 的基本类型来说，可以使用 == 操作符进行比较；
  - 对于引用对象，可以递归的调用 equals 方法；
  - 对于 float 和 double 可以使用其包装类的 equals 方法，如 Float.equals。
  - 对于数组域中的每个元素都很重要的话，可以使用 Arrays.equals。
  域的比较顺序可能会影响到 equals 方法的性能。为了获得最佳的性能，应该最先比较最有可能不一致的域，或者是开销最低的域，最理想的情况是两个条
  件同时满足的域。
 5.当你编写完成了 equals 方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？

覆盖 equals 的最后告诫：
 - 覆盖 equals 时重要覆盖 hashCode。
 - 不要企图让 equals 方法过于智能。
 - 不要将 equals 声明中 Object 对象替换成其他的类型。



2.第九条：覆盖 equals 时重要覆盖 hashCode。

Object 规范（JavaSE6，摘抄）：
 - 在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对同一个对象调用多次，hashCode 方法必须始终如一的返回
 同一个整数。
 - 如果两个对象根据 equals 方法的比较操作是相等的，那么调用这两个对象中任意一个对象的 hashCode 方法都必须产生同样的整数结果。
 - 如果两个对象根据 equals 方法的比较操作是不相等的，那么调用这两个对象中任意一个对象的 hashCode 方法，则不以预定要要产生不同的整数结果。
 但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提升散列表的性能。

一个很常见的错误根源是在于没有覆盖 hashCode 方法。在每个覆盖了 equals 方法的类中，也必须覆盖 hashCode 方法。因为没有覆盖 hashCode 而违
反的关键约定是第二条：相同的对象必须具有相同的散列码。

在散列码的计算过程中，可以把冗余域排除在外。
必须排除 equals 比较计算中没有用到的任何域，否则很有可能违反 hashCode 约定的第二条。

如果一个类是不可变的，并且计算散列码的开销也比较大，就应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码。



3.第十条：始终要覆盖 toString。

提供好的 toString 实现可以使类用起来更加舒适。

当对象被打印出来时，toString 方法会被自动调用。

在实际应用中，toString 方法应该返回对象中包含的所有值得关注的信息。



4.第十一条：谨慎地覆盖 clone。

Clone 方法的通用约定（JavaSE6 摘抄）：
 - x.clone() != x;
 - x.clone().getClass() == x.getClass();
 - x.clone().equals(x);

永远不要让客户去做任何类库能够替客户完成的事情。

拷贝构造器是一个不错的选择。



5.第十二条：考虑实现 Comparable 接口。

违反了 hashCode 约定的类会破坏其他依赖于散列做法的类一样，违反了 compareTo 约定的类也会破坏其他依赖域比较关系的类。

compareTo 也遵守自反性、对称性和传递性。

如果一个类有多个关键域，那么，你必须从最关键的域开始，逐步进行到所有的域。如果某个域的比较产生了非零的结果（零代表相等），则整个比较操作结束，
并返回该结果。如果最关键的域是相等的，则进一步比较次最关键的域，以此类推。如果所有的域都是相等的，则对象就是相等的，并返回零。