第七章 复用类

1.复用类的两种方式：
 - 组合；
 - 继承。
2."source = " + source，由于只能将一个 String 对象和另一个 Sting 对象相加，而 String 对象在在与对象尽享拼接的时候，编译器会告诉你："我将
调用该对象的 toString()，把 source 转换成为一个 String。"，这样就能够进行拼接了。
3.除非已明确指出要从其他类中继承，否则就是在隐式的从 Java 的标准根类 Object 进行继承。
4.继承并不只是复制基类的接口。当创建了一个到处类的对象时，该对象包含了一个基类的子对象。所以对基类子对象的正确初始化是至关重要的。
5.在组合与继承中选择：
 - 组合技术通常用于现在新类中使用现有类的功能而非它的接口。使用新类的用户看到的只是为新类所定义的接口，而非说嵌入（组合）对象的接口。
 - 在继承的时候，使用某个现有类，并开发一个它的特殊版本。通常，这意味着你在使用一个通用类，并为了某种特殊需要而将其特殊化。
6.在理想世界中，仅靠关键字 private 就已经足够了。但在实际项目中，经常会想要将某些事物尽可能的对这个世界隐藏起来，但仍然允许导出类的成员访问
它们。而关键字 protected 就是起这个作用。
7."为新类提供方法"并不是继承技术中最重要的方面，其最重要的方面是用来表现新类和基类之间的关系。这种关系可以用"新类是现有类的一种类型"这句话加
以概括。有了这个概念之后我们就可以引入向上转型了。
8.为什么称为向上转型？
 - 由导出类转型成基类，在继承图上（类继承图的绘制）是向上移动的，因此一般称为向上转型。
 - 由于向上转型是从一个叫专用类型向较通用类型转换，所以总是很安全的。
 - 一个导出类可能比基类含有更多的方法，但它必须至少具备基类中所含有的方法。
9.到底是该用组合还是继承，一个最清晰的判断方法就是问一问自己是否需要从新类向基类进行向上转型。如果必须向上转型，则继承是必要的；但如果不需要
则应当好好考虑自己是否需要继承。
10.final 通常指的是"这是无法改变的。"， 不过不想做改变可能出于两种理由：设计或效率。然而对于不同的使用场景还存在着细微的差别。
11.final 修饰数据：
 - 一个永远不改变的编译时常量。
 - 一个在运行时被初始化的值，而不希望它被改变。
 - 然后对于基本类型来说，表示的是数值恒定不变，而对于对象引用来说，则表明引用恒定不变，但对象其自身的却可以被修改。
 - 一个既是 static 又是 final 的域只占据一段不能改变的存储空间。定义为 static，则强调只有一份（在类装载的时候被初始化，而不是每次创建新对
 象时都初始化）；定义为 final，则说明它是一个常量。
12.final 修饰方法：
 - 把方法锁定，以防任何继承类修改它的含义。想要确保在继承中使方法行为保持不变，并且不会被覆盖。
 - 过去建议使用 final 的第二个原因是效率。在 Java 的早期实现中，如果讲一个方法指明为 final，就是同意编译器将针对该方法的所有调用都转为内
 嵌调用。
 - 现在使用 final，只有在想要明确禁止覆盖时，才会将方法设置为 final。
 - 所有类中 private 的方法都隐式的指定为是 final 的。由于外界无法调用 private 方法，所以也就无法覆盖它。
13."覆盖"只有在某方法是基类的接口的一部分时才会出现。如果某方法是 private，它就不是基类的接口的不一部分，它仅是隐藏于类中的代码。
14.final 修饰类：
 - 出于某种考虑，你对该类的设计不需要做任何变动，或者出于安全的考虑，你不希望它有子类。
 - final 类中的所有方法都隐式指定为是 final 的。
15.一般来说，"类的代码在初次使用时才加载。"，这通常十字架在发生于创建累的第一个对象之时，但是当访问 static 域或 static 方法时，也会发生加
载。构造器也是 static 的，尽管 static 关键字并没有显式的写出来。因此更准确的讲，类是在其任何 static 成员被访问时加载的。
16.在设计一个系统时，目标应该是找到或创建某些类，其中每个类都有具体的用途，而且既不会太大（包含太多的功能而难以复用），也不会太小（不添加其他
功能就无法使用）。如果你的设计变得太过复杂，通过将现有类拆分为更小的部分而添加更多的对象，通常会有所帮助。