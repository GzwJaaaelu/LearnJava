第八章 多态

1.在面向对象的程序设计语言中，多态是继数据抽象和继承之后的第三种基本特征。
2.多态通过分离做什么和怎么做，从另一角度将接口和实现分离开来。
3.多态的作用是消除类型之间的耦合关系。在前一章中我们u 已经知道，继承允许将对象视为它自己本身的类型或者其基类型来加以处理，而同一份代码也将可以毫无差
别的运行在这些不同类型之上了。多态方法调用允许一种类型表现出与其他相似类型之间的区别，只要它们都是从同一基类导出而来的。这种区别是根据方法行为的不同
而表现出来的，虽然这些方法都可以通过同一个基类来调用。
4.多态也称为动态绑定、后期绑定或运行时绑定。
5.对象既可以作为它自己本身的类型使用，也可以作为它的基类型使用。而这种把对某个对象的引用视为对其基类型的引用的做法被称作向上转型。
6.忘记对象的类型：
 - fun(基类)，为什么方法要这样写，而不是写成具体的 fun(具体子类 A) 呢？而且后者看上去更直观。但这样做会引发一个重要的问题，如果后续基类衍生出更多
 子类，而这些子类都要调用 fun(xxx) 就导致了我们要为每一个基类衍生出来的子类都编写一个新的 fun(xxx)。这样做当然行得通，但是你就需要为自己增加更多
 工作量。
 - 如果我们只写一个简单的方法，它仅接收基类作为参数，而不是那些特殊的导出类。这样我们就不用管导出类的存在，编写的代码只和基类打交道。
 - 将一个方法调用同一个方法主体关联起来被称作绑定。
 - 当我们在做 fun(基类) 这种设计的时候，编译器这么才能知道这个基类引用的指向的具体子类 A 对象而不是其他别的子类对象呢？解决这个问题的办法就是后期
 绑定。它的含义就是在运行时根据对象的类型进行绑定。这样就使我们是可以在运行时判断对象的类型，从而调用恰当的方法。
7.Java 中除了 static 方法和 final 方法（private 方法属于 final 方法）之外，其他所有的方法都是后期绑定。这意味着在通常情况下，我们不必判断是
否应该进行后期绑定————它会自动发生。
8.前面一张提到的 final 方法除了可以防止其他人覆盖方法，更重要的一点或许是：这样做可以有效的"关闭"动态绑定。或者说，告诉编译器不需要对其进行动态绑
定。这样，编译器就可以为 final 方法调用生成更为有效的代码。然而，大多数情况下，这样做对但程序的整体性能不会有什么改观。
9.多态是一项让程序员"将改变的事物与未变的事物分离开来"的重要技术。
10.缺陷：
 - 无法覆盖私有方法。
 - 无法覆盖字段与静态方法。
11.静态方法是与类，而并非与单个对象相关联的。
12.初始化顺序：
 父类静态字段 -> 父类静态代码块 -> 子类静态字段 -> 子类静态代码块 -> 父类成员字段 -> 父类成员代码块 -> 父类构造 -> 子类成员字段
 -> 子类成员代码块 -> 子类构造
13.基类的构造器总是在导出类的构造过程中被调用，而且按照继承层次逐渐向上链接，以使得每个基类的构造器都能得到调用。
14.调用构造器要遵照下面这个顺序：
 - 调用基类构造器。并且如果有父类还会去调用基类的基类的构造，递归下去。
 - 按声明顺序调用成员的初始化方法。
 - 调用导出类构造器的主体。
15.万一某个子对象依赖其他对象，销毁的顺序应该和初始化顺序相反，对于字段，则意味着与声明的顺序相反。对于基类，应该首先对导出类进行清理，然后才是基类。
这是因为导出类的清理可能会调用基类中的某些方法，所以需要使基类中的构件仍起作用而而不应过早的销毁它们。
16.在父类构造器中调用被覆盖的方法，最终被执行的是子类中被覆盖的方法。
17.一条通用的准则："用继承表达行为间的差异，并用字段表示状态上的变化"。
18.多态意味着"不同的形式"。在面向对象的程序设计中，我们持有从基类继承而来的相同接口，以及使用该接口的不同形式：不同版本的动态绑定方法。
