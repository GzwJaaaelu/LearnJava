第十章 并发

1.第七十四条：谨慎的实现 serializable 接口。

为继承而设计的类应该尽可能少的去实现 Serializable 接口，用户的接口也应该尽可能少的继承 Serializable 接口。

你必须既要确保"序列——反序列化"过程成功，也要确保结果产生的对象真正是原始对象的复制品。

内部类不应该实现 Serializable。
它们使用编译器产生的合成与来保存只想外围实例的引用，以及保存来值外围作用域的局部变量的值。

静态成员类可以实现 Serializable。



2.第七十五条：考虑使用自定义的序列化形式。

如果没有先认真考虑默认的序列化形式是否合适，则不要贸然接受。

如果一个对象的无力表示法等同于它的逻辑内容，可能就适合于使用默认的序列化形式。

当一个对象的无力表示法与它的逻辑数据内容有实质性的区别时，使用默认序列化形式会有以下四个缺点：
 - 它使这个类的导出 API 永远的束缚在该类的表示法上；
 - 它会消耗过多的空间；
 - 它会消耗过多的时间；
 - 它会引起栈溢出；

不管你选择了那种序列化形式，都要为自己编写的米格可序列化的类声明一个显式的序列版本 UID。



3.第七十六条：保护性的编写 readObject 方法。

readObject 方法实际上相当于另一个公有的构造器，如果其他的构造器一样，它也要要求注意同样的所有注意实现。构造器必须检查其他参数的有效性，并且
在有必要的适合对参数进行保护性拷贝，同行的，readObject 方法也需要这样做。

当一个对象被反序列化的适合，对于客户端不应该拥有的对象引用，如果哪个域包含了这样的对象引用，就必须要做保护性拷贝，这是非常重要的。

有助于编写出更加健壮的 readObject 方法的指导方针：
 - 对于对象引用域必须保持为私有的类，要保护性的拷贝这些域中的每个对象，不可变类中的可变组件就属于这一类别；
 - 对于任何约束条件，如果检查失败，则抛出一个 InvalidObjectException 异常，这些检查应该跟在所有的保护性拷贝之后；
 - 如果整个对象图在反序列化之后必须进行验证，就应该使用 ObjectValidation 接口；
 - 无论是直接方式还是间接方式，都不要调用类中任何可覆盖的方法；



4.第七十七条：对于实例控制，枚举类型优先于 readResolve。

如果一个单例类实现了 Serializable 接口，那么它就不再是一个单例类了。任何 readObject 方法，不管是是显式的还是默认的，它都返回一个新建的实
例，这个新建的实例不同于该类初始化时创建的实例。

readResolve 特性允许你用 readObject 创建的实例代替另一个实例。

事实上，如果依赖 readResolve 进行实例控制，带有对象引用类型的所有实例域则都必须声明为 transient 的。



5.第七十八条：考虑序列化代理代替序列化实例。

