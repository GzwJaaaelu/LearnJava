第五章 初始化与清理

//  初始化与构造器
1.创建对象的时候，将会为对象分配存储空间，并调用相应的构造器。这就确保了在你能够操作兑现之前，它已经被恰当的初始化了。
2.不接受任何茶树的构造器叫做默认构造器，也叫无参构造器。当然也可以为构造器设置参数。
3.构造器是一种特殊类型，因为它没有返回值。
4.所谓方法则是给某个动作取得名字。
5.当创建一个对象时，也就给此对象分配到的存储空间取了一个名字。通过使用名字，你可以引用所有的对象和方法。
//  重载
6.在 Java（C++）里。构造器是签字重载方法名的另一个原因。既然构造器的名字已经由类名所决定，就只能有一个构造器名。那么要想
用多种方式创建一个对象该怎么办呢？假设你要创建一个类，既可以用标砖方式进行初始化，也可以从文件读取信息来初始化。这就需要
两种构造器：一个默认构造器，另一个去字符创作为形式参数——该富川表示初始化对象所需要的文件名称。由于都是构造器，所以它们
必须有相同的名字，即类名。为了让方法名相同而形式参数不同的构造器存在，必须用到方法重载。
7.很多时候我们的初始化是有语义的，比如，创建 Tree 对象时，既可以不含参数，可以树的高度当参数。前者表示一颗树苗，后者表示
已有一定高度的树木。要支持这种创建方式，得有一个默认构造器和一个采用现有高度作为参数的构造器。
8.方法重载带来的好处就是用统一名字来表示同一事物，要是明显相同的概念使用了不同的名字，那一定会让人很纳闷。
9.Java 如何通过相同的方法名来知道你要调用的是哪一个呢？其实规则很简单：每个重载的方法都必须有一个独一无二的参数类型列表。
顺子参数顺序不同也足以区分两个参数。不过一般不这么做。
10.不过涉及基本类型的重载你就要稍微注意一点了，毕竟基本类型是可以从一个“较小”的类型自动提升为一个“较大”的类型。不过，
方法接受较小的基本参数类型作为参数，如果传如的实际参数较大，就得通过类型转换来执行窄化转化。
11.我们无法通过返回来区别分重载的方法，所以也就无法使用。
12.如果你的类中没有构造器，则编译器会自动帮你创建一个默认的构造器。但如果你已经定义了一个构造器（无论是否有参数），编译器
就不会帮你自动创建默认的构造器。
//  this 关键字
13.如果有一个类型的两个对象，分别是 a 和 b。如何才能让整个两个对象都能调用相同的方法呢？
{
    Test a = new Test();
    Test b = new Test();

    a.test(1);
    b.test(2);
}
其实编译器做了一些幕后工作，它暗自把“所操作对象的引用”当做第一个传输传给给 test()。所以上述两个方法看书去就成了这样：
    Test.test(a, 1);
    Test.test(b, 2);
这是内部表示形式，但是我们不能这样写，毕竟编译是通不过的。
假设你希望在方法的内部获得当前对象的引用。由于这个引用是由编译器“偷偷”传入的，所以你没有标识符可用。但是，为此有个专门
的关键字：this。this 关键字中只能在方法内部使用，表示对“调用方法的那个对象”的引用。
不过我们在同一个类的方法中调用同一个类的另一个方法无需使用 this.methodName() 这种形式，直接写方法名即可，倒是需要返回当前
对象的引用的引用时可以这样写，例如：
public class Leaf {
    int i = 0;

    Leaf increment() {
        i++;
        return this;
    }
}
另外， this 关键字对于将当前对象传递给其他方法也有有用。
当一个类中有多个构造器时，有可能想在一个构造器中调用另一个构造器，这时候可以用 this 完成。但是一个构造器中想要调用别的构
造器的话只能有一个 this(...) 而且必须要放在第一句，否则编译器会报错。
14.static 方法中没有 this，所以在 static 方法的内部不能调用非 static 方法。
15.finalize() 它的工作原理“假定”是这样的：一旦垃圾回收器准备好释放对象占用的内存空间，将首先调用其 finalize() 方法，并
且在下一次垃圾回收动作发生时，才会真正回收对象占用的内存。
16.垃圾回收本身也有开销，要是不使使用它。
17.垃圾回收只与内存有关。也就是说，使用垃圾回收器的唯一原因是为了回收程序不再使用的内存。
18.finalize() 更多用于释放非 Java 的方式为对象分配了存储空间，比如 native 方法中分配的存储空间。所以它确实不是进行普通的
清理工作中的合适场合。
19.finalize() 还有一个有趣的用法，就是对象终结条件的验证。
20.垃圾回收期器依据的思想是：对于任何“活”的对象，一定能最终追溯到其存活在堆栈或静态存储区之中引用。这个引用链条可能会穿
过数个对象层次。
21.Java 有一种名为停止——复制的回收做法，显然这意味着，先暂停程序的运行（所以他不属于后台回收模式），然后将所有的存活对
象从当前堆复制到另一个堆，没有被复制的全部都是垃圾。当对象被复制到新堆时，他们是一个挨一个的，所以新堆保持紧凑排列。
不过这种做法明显是低效的，而且得有两个堆。还可能存在当前复制的堆可能存在的垃圾只是少量甚至没有，这时候还是需要从一处复制
到另一处。
为了避免第二种情况发生，这时候标记——清扫的方式会提升不少效率。
22.标记——清扫：还是先遍历找到所有存活的对象，然后，每当它找到一个存活对象，就会给对象设一个标记，这个过程中不会回收任何
对象。只有全部标记工作完成的时候，清理工作才会开始。在清理过程中，没有标记的对象将被释放，不会发生任何复制动作。所以剩下
的堆空间是不连续的，垃圾回收器要是希望得到连续的空间，就得重新整理剩下的对象。
23.无论创建多少个对象，静态数据都只占用一份存储区域。
24.初始化的顺序是先静态对象（如果它们尚未被初始化），而后是“非静态”对象。要执行 main() 首先要初始化其静态域。
25.以 Dog 为例，总结一下对象的创建过程：
 - 即使没有显示的使用 static 关键字，构造器实际上也是静态方法。因此，当首次创建类型为 Dog 的对象时（构造器可以看成静态方
 法），或者 Dog 类的静态方法/静态域首次被访问时，Java 解释器必须寻找类路径，以定位 Dog.class 文件。
 - 然后载入Dog.class（这将会常见一个 Class 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只在 Class 对象首次
 加载的时候进行。
 - 当用 new Dog() 创建对象时，首先将在堆上为 Dog 对象分配足够的存储空间。
 - 这块存储空间会被清零，这就自动的将 Dog 对象中的所有基本类型的数据都设成了默认值，而应用则被设置成了 null。
 - 执行所有出现与字段定义出的初始化动作。
 - 执行构造器。尤其是涉及到集成的时候会牵涉很多动作。
26.可变参数其实就是一个数组。