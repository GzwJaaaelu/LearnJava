第十章 并发

1.第六十六条：同步访问共享的可变数据。

如果没有同步，一个线程的变化就不能被其他线程看到。同步尽可以阻止一个线程看到对象处于不一致的状态之中，它还可以保证进去同步方法或者同步代码块
的每个线程，都看到由同一个锁保护的之前所有的修改效果。

为了在线程之间进行可靠的通信，也为了互斥访问，同步是必要的。

虽然 volatile 修饰符不执行互斥访问，但它可以保证任何一个线程在读取该域的时候都将看到最近刚刚被写入的值。

避免本条目中所讨论的问题最佳办法是不共享可变的数据。要么共享不可变的数据，要么压根不共享。

简而言之，当多个线程共享可变数据的时候，每个读或者写数据的线程都必须执行同步。
如果没有同步，就无法保证一个线程所做的修改可以被另一个线程获知。



2.第六十七条：避免过度同步。

过度同步可能会导致性能降低、死锁，甚至不确定的行为。

在一个被同步的区域内部，不要调用设计成要被覆盖的方法，或者是由客户端以函数对象呃形式提供的方法。
从包含该同步区域的类角度来看，这样的方法是外来的。这个类不知道该方法会做什么，也无法控制它。

通常，你应该在同步区域内做尽可能少的工作。

简而言之，为了比 main死锁和数据破坏，千万不要从同步区域内部调用外来方法。
更为一般的讲，要尽量限制同步区域内部的工作量。



3.第六十八条：executor 和 task 由于线程。



4.第六十九条：并发工具优先于 wait 和 notify。

既然正确的使用 wait 和 notify 比较困难，就应该用更高级的并发工具来替代。

始终应该使用 wait 循环模式来调用 wait 方法；永远不要在循环之外调用 wait 方法。



5.第七十条：线程安全的文档化。

当一个类的实例或者静态方法被并发使用的时候，这类的行为如何，是该类与其客户端程序建立的约定重要组成部分。

"出现了 synchronized 关键字就足以用文档说明线程安全性"的这种说话银行了一个错误的观念，即认为线程安全性是一种"要么全有要么全无"的属性。
实际上，线程安全性有多种级别。一个类为了可被多个线程安全的使用，必须在文档中清楚的说明它所支持的线程安全级别。

下面的列表概括了线程安全性的集中级别：
 - 不可变的————这个类的实例是不可变的。所以，不需要外部的同步。
 - 无条件的线程安全————这个类的实例是可变的，但是这个类内部有着足够的内部同步，所以它的实例可以被并发使用，无需任何外部同步。
 - 有条件的线程安全————除了有些方法为进行安全的并发使用而需要外部同步之外，这种线程圈级别与无条件的线程安全相同。
 - 非线程安全————这个类型的实例是可变的。为了并发的使用它们客户端必须利用自己选择的外部同步包围每个方法的调用。
 - 线程对立的————这个类不能安全的就被多个线程并发使用，即使所有的方法调用都被外部同步包围。



6.第七十一条：慎用延迟初始化。

延迟初始化是延迟到需要域的值时才开始将它进行初始化的这种行为。

延迟初始化就像一把双刃剑。它降低了初始化类或者创建实例的开销，却增加了访问被延迟初始化的域的开销。
根据延迟初始化的域最终需要初始化的比例、初始化这些域要多少开销，以及每个域多久被访问一次，延迟初始化（就像其他的需要优化一样）实际上降低了性
能。

如果出于性能的考虑而需要对静态域使用延迟初始化，就是用 lazy initialization holder class 模式。

如果出于性能的考虑而需要对实例域进行延迟初始化，就是用双重检查模式。

简而言之，大多数的域应该正常的进行初始化，而不是延迟初始化。
对于实例域，就是用双重检查模式；对于静态域，则使用 lazy initialization holder class idiom。对于可以接受重复初始化的实例域，也可以考虑
使用单重检查模式。



7.第七十二条：不要依赖于线程调度器。

当有多个线程可以运行时，由线程调度器决定那些线程将会运行，以及运行多长时间。

保持可运行线程数量尽可能的少的主要原因是，让每个线程做些有意义的工作，然后等待更多有意义的工作。
如果线程没有在做有意义的工作，就不应该运行。
这意味着适当的规定线程的大小，并且使任务保持适当的小，彼此独立。任务不应该太小，否则分配的开销也会影响性能。

通过调整某些线程的优先级来改善应用程序的响应能力，这样做并非不可理，却是不必要的，也是不可移植的。

不要依赖 Thread.yield 或者线程优先级。这些设施仅仅对调度器做些暗示。



8.第七十三条：避免使用线程组。



