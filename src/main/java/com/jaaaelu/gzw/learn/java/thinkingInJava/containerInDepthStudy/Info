第十七章 容器深入研究

1.存入 Set 的每个元素都必须是唯一的，因为 Set 不保存重复的元素。加入 Set 的元素必须定义 equal() 方法以确保对象的唯一性。Set 和 Collection
 有完全一样的接口。Set 的接口不保证维护元素的次序。
2.HashSet：为快速查找而设计的 Set。存入 HashSet 的元素必须定义 hashCode();
3.TreeSet：保持次序的 Set。底层为树结构。使用它可以从 Set 中提取有序的序列。元素必须实现 Comparable 接口。
4.LinkedHashSet：具有 HashSet 的查询速度，且内部使用链表维护元素的顺序（插入的顺序）。于是在使用迭代器遍历 Set 时，结果会按照元素插入的
次序显示。元素也必须定义 hashCode() 方法。
5.如果使用 Set 的话，默认选择 HashSet 即可，因为其对速度进行了优化。
6.对于良好的编程风格而言，你应该在覆盖 equals() 方法时，总是同时覆盖 hashCode() 方法。
7.HashMap：Map 基于散列表的实现。插入和查询"键值对"的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。默认选择 HashMap
即可，因为它对速度进行了优化。
8.LinkedHashMap：类似于 HashMap，但是迭代遍历它时，取得"键值对"的顺序是其插入词序，或者是最近最少使用（LRU）的次序。只比 HashMap 慢一点；
而迭代访问时反而更快，因为使用链表维护内部次序。
9.TreeMap：基于红黑树的实现。查看"键"或"键值对"时，它们会被排序。TreeMap 的特点在于，所得到的结果是经过排序的。TreeMap 是唯一带 subMap()
方法的 Map，它可以返回一个子树。
10.WeakHashMap：弱键映射，允许释放映射所指向的对象；这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个"键"，则此"键"可以垃圾收集
器回收。
11.ConcurrentHashMap：一种线程安全的 Map，它不涉及同步加锁。
12.IdentityHashMap：使用 == 替换 equals() 对"键"进行比较的散列映射。专门解决特殊问题而设计的。
13.如果我们没有重写 hashCode() 方法，默认我们使用的 Object 的 hashCode() 方法，而它默认是使用对象的地址计算散列码。因此一个类中，两个
new 出来的对象，它们的地址不等，也就导致 hashCode() 不等。
14.默认的 Object.equals() 只是比较对象的地址。
15.正确的 equals() 方法必须满足下列 5 个条件：
 - 自反性。对任意 x，x.equals(x) 一定为 true。
 - 对称性。对任意 x 和 y，如果 y.equals(x) 返回 true，则x.equals(y) 也返回 true。
 - 传递性。对任意 x、y、z，如果有 x.equals(y) 返回 true，y.equals(z) 返回true，则 x.equals(z) 返回 true。
 - 一致性。对任意 x 和 y，如果对象中用于等价比较的信息没有改变，那么不论调用 x.equals(y) 多少次，返回结果应该保持不变，要么一致 true，要
 么一致返回 false。
 - 对任何不是 null 的 x，x.equals(null) 一定返回 false。
16.想要比较 hashCode() 之前，一定要确保重写了 equal()。
17.使用散列的目的在于：想要使用一个对象来查找另一个对象。
18.散列的价值在于速度：散列是的查询得以快速进行。而如果使用简单的线性查询，那么查询速度最慢。
19.散列键键保存在某处，以便能够很快找到。存储一组元素最快的数据结构是数据。所以使用它来表示键的信息。
数组并不保存键本身，而是通过键对象生成一个数字，将其作为数组的下表，而这个数字就是散列码。
于是查询一个值的收腰过程就是计算散列码，然后使用散列码查询数组。
20.设计 hashCode() 是最重要的因素就是：无论何时，对同一个对象调用 hashCode() 都应该生成相同的值。
21.要想是 hashCode() 实用，它必须速度快，并且必须有意义。
22.好的 hashCode() 应该产生分布均匀的散列码。
23.容器之间的区别通常归结为由什么在背后"支持"它们。也就是说，所使用的接口是由什么样的数据结构实现的。例如 ArrayList 底层由数组支持；而 LinkedList
是由双向链表实现的。因此，如果要经常在表中插入或删除元素，LinkedList 就比较合适；否则应该使用速度更快的 ArrayList。
24.负载因子轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的。
25.HashMap 使用的默认负载因子是 0.75（只有当表达到四分之三满的时，才进行再散列），这个因子在时间和空间代价之间达到了平衡。更高的负载因子可
以降低表所需的空间，但是会增加查找代价，这很重要，因为查找使我们大多数时间里所做的操作。
26.创建 Collection 或 Map 为不可修改的，也就是只读的 Collection 或 Map，可以使用 Collections。
27.创建线程安全的容器也可以是用 Collections。
28.容器的快速报错机制，能够防止多个进程同时修改同一个容器。"快速报错"机制的原理：只需要创建一个迭代器，然后迭代器所指向的 Collection 添加
点什么机会抛出 ConcurrentModificationException 异常，而 ConcurrentHashMap、CopyOnWriteArrayList 和 CopyOnWriteArraySet 都使用
了避免 ConcurrentModificationException 的技术。
29.对象时可获得的，是指此对象可在程序中的某处找到。这意味着你的栈中又一个普通的引用，而它正指向此对象；也可能是你的引用指向某个对象，而那个对
象含有另一个引用指向正在讨论的对象；也可能有很多的中间连接。如果一个对象是"可获得的"，垃圾回收器就不能释放它，因为它仍然为你的程序所用。如果
一个对象不是"可获得的"，那么你的程序将无法继续使用到它，所以将其回收是安全的。
30.以 Reference 对象作为你和普通引用之间媒介，以下类引用强度依次递减：
 - SoftReference 用以实现内存敏感的高速内存。
 - WeakReference 是为实现"规范映射"而设计的，它不妨碍垃圾回收器回收映射的"键"（或"值"）。"规范映射"中对象的实例可以在程序的多处被同时使用，
 以节省存储空间。
 - PhantomReference 用以调度回收垃圾前的清理工作，它比 Java 终止机制更灵活。
