第四章 类和接口

1.第十三条：使类和承欢的访问性最小。

要区分设计良好的模块与设计不好的模块，最重要的因素在于，这个模块对于外部的其他模块而言，是否隐藏其内部数据和其他的设计细节。设计良好的模块会
隐藏所有的实现细节，把它的 API 与它的实现清晰的隔离开来。然后，模块之间只通过他们的 API 进行通信，一个模块不需要知道其他模块内部工作的情况。

信息隐藏的原因有很多，其中之一就是，它可以有效的解除组成系统的各模块之间的耦合关系，使得这些模块可以独立的开发、测试、优化、使用、理解和修改。

尽可能的使每个类不被外界访问。

如果把你对外提供的类和接口做成公有的，你就有责任永远的支持它，以保持它们的兼容性。如果做成包级私有，它实际上成个这个包的实现的一部分，而不是
该包到处的 API 的一部分，在以后的版本中，可以对它进行修改、替换，或是删除，而无需担心会影响到现有的客户端程序。

如果一个包级私有的类或接口只是在某一个类的内部被用到，就应该考虑使它成为唯一使用它的那个类的嵌套类。

Java 的四种访问级别：
 - private；
 - 缺省；
 - protected；
 - public；

实例域据不能是公有的。
包含公有可以变域的类并不是线程安全的。

如果 final 域包含可变对象的引用，它便具有非 final 域的所有缺点。



2.第十四条：在公有类中使用访问方法而非公有域。

如果类可以在它所在的包的外部进行方法，就提供访问方法，以保留将来改变该类的内部表示法的灵活性。

公有类永远不应该暴露可变的域。



3.第十五条：使可以变性最小化。

不可变类只是其实力不能被改变的类。每个实力中包含的所有信息都必须在创建该实例的时候就提供，并在对象的整个生命周期内固定不变。
不可变的类比可变类更加易于设计、实现和使用。它们不容易出错，且更加安全。

为了使类成为不可变类，要遵守下面五条规则：
 - 不要提供能任何会修改对象状态的方法；
 - 保证类不会被扩展（为了防止子类化，类声明成 final 的）；
 - 使所有的域都是 final 的；
 - 使所有的域都成为私有的；
 - 确保对于任何可变组件的互斥访问；

不可变对象本质上是线程安全的，它们不要求同步。
当多个线程并发访问这样的对象时，他们不会遭到破坏。
不可变对象可以被自由的共享。
"不可变对象可以被自由的共享"导致的结果是，永远也不需要进行保护性拷贝。因为这些拷贝始终等于原始的对象。

不可变类的真正唯一缺点是，对于每个不同的值都需要一个单独的对象。
如果你执行一个多步骤的操作，并且每个步骤都会产生一个新的对象，除了最后的结果之外其他的对象最终都会被丢弃，此时性能问题就会显露出来。
处理这种问题有两种方法：
 - 先猜测一下会经常用到哪些夺不走的查欧洲，然后将它们作为基本类型提供；
 - 提供一个公有的可变配套类（例：String 和 StringBuilder）；

使用静态工厂来替代公有的构造器。

除非有很好的理由要让类成为可变的类，否则就应该是不可变的。

只有当你确认域欧必须实现令人满意的性能时，才应该为不可变的类提供公有的配套类。

如果类不能被做成不可变的，仍然应该尽可能的限制它的可变形。



4.第十六条：复合优先于继承。

继承是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。使用不当会导致软件变得脆弱。

只有当子类和超类之间确实存在子类型关系时，使用继承才是恰当的。

包装类不仅比子类更加健壮，而且功能也更加强大。



5.第十七条：考要么为继承而设计，并提供文档说明，要么就禁止继承。

为继承设计的类的文档必须精确的描述覆盖每个方法所带来的影响。

对于为了继承而设计的类，唯一的测试方法就是编写子类。

构造器决不能调用可被覆盖的方法，无论是直接调用还是间接调用。



6.第十八条：接口优于抽象类。

接口和抽象类这两种机制最明显的区别在于，抽象类允许包含某些方法的实现，但是接口则不允许。（Java8 种引入了接口的默认实现）
一个更为重要的却别在于，为了实现由抽象类定义的类型，类必须成为抽象类的一个子类。任何一个类，只要它定义了所有必要的方法，并且遵守通用约定，它
就被允许实现一个接口，而不管整个类是处于类层次的哪个位置。

现有的类可以很容易被更新，以实现新的接口。
接口是定义 mixin（混合类型）的理想选择。
接口允许我们构造非层次结构的类型框架。

设计公有的接口要非常谨慎。接口一旦被公开发行，并且已经被广泛实现，再想该百年之后个接口几乎是不可能的。



7.第十九条：接口只用于定义类型。

当类实现接口时，接口就充当可以引用这类的实例的类型。因此，类实现了接口，就表明客户端可以对整个类的实例实施某些动作。为了任何其他目的而定义接
口是不恰当的。

常量接口模式是对接口的不良使用。



8.第二十条：类层次由于标签类。

类层次可以用来反应类型之间本质上的层次关系，有助于增强灵活性，并进行更好的编译时类型检查。



9.第二十一条：用函数对象表示策略。

通过声明一个接口来表示策略，并且为每个具体策略声明一个实现了该接口的类。当一个具体策略只被使用一个时，通常通过使用匿名类来声明和实例化整个具
体策略类。当一个具体策略是设计用来重复使用的时候，它的类通常就被实现为是有的静态成员类，并通过公有的静态 final 域被导出，其类型为该策略接口。



10.第二十二条：优先考虑静态成员类。

嵌套类是指被定义在另一个类的内部的类。
嵌套类有四种：静态成员类、非静态成员类、匿名类和局部类。
除了第一种外，其他三种都被成为内部类。

静态成员类可以看作是普通的类，只是碰巧被生命在另一个类的内部而已。

静态成员类和非静态成员类之间的区别在于静态成员类的声明中包含修饰符 static。尽管语法相似，但是两者有很大不同。非静态成员类的每个实例都隐含着
与外围类的一个外围实例相关联。
在没有外围实例的情况下，想要创建非静态成员类的实例是不可能的。

如果声明成员类不要求访问外围实例，就要始终把 static 修饰符放在它的声明中，使它成为静态成员类，而不是非静态成员类。如果忽略了 static 修饰符，
则每个实例都将包含一个只想外围对象的引用。保存这份引用会消耗时间和空间，并且会导致外围实例在符合垃圾回收时缺仍然得以保留。

匿名类和局部类只有在非静态环境中定义的时候，才有外围引用，它们也不能包含静态成员。

