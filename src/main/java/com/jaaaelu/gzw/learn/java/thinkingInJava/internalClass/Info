第十章 内部类

1.可以将一个类的定义放在另一个类的定义内部，这就是内部类。
2.当生成一个内部类的对象时，此对象与制造它的外围对象之间就有了一种联系，所以它能访问其外围对象的所有成员，而不需要任何特殊条件。此外，内部类
还拥有其所有元素的访问权。
3.内部类可以访问其外围类的方法和字段，就像自己拥有它们似的。
4.内部类自动拥有对其外围类所有成员的访问权。这是如何做到的呢？当某个外围类的对象创建了一个内部类对象时，此内部对象必定会秘密补货一个只想那个
外围类对象的引用。然而在你访问此外围类的成员时，就是用那个引用来选择外围类的成员。编译器会帮你处理这些细节，但你现在可以看到：内部类的对象只
能在与其外围类的对象相关联的情况下才能被创建（就像你应该看到的，在内部类是非 static 类时）。构建内部类对象时，需要一个指向其外围类对象的引用。
如果编译器访问不到那个引用就会报错。
5.想要直接创建内部类的对象，你不能按照你想象的方式，去引用外部类的名字，而是必须使用外部类的对象来创建该内部类对象，就像在下面这段代码：
    InnerTest test = new InnerTest();
    //  这里其实不能写成 test.new InnerTest.Inner("From New");
    InnerTest.Inner inner = test.new Inner("From New");
使用这种内部时，其实是在拥有外部类对象之间不可能创建内部类对象的。这是因为内部类对象会暗暗的连接到创建的外部类对象上。
但是如果你是用的是嵌套类（静态内部类），那么就不需要对外部类对象的引用。创建方式也有所改变，就像下面这段代码：
    InnerTest.StaticInner staticInner = new InnerTest.StaticInner("Static Inner");
6.内部类也可以用于向上转型，此时此内部类——某个接口的实现——能够完全不可见，并且不可用。所得到的只是指向基类或接口的引用，所以能够很方便的隐藏
实现细节。
7.继承内部类时，一定需要正确初始化其外围类。
8.在方法中创建一个类，这种类被称作局部内部类，如果在这个方法外，任何人不能都访问不到。
9.在匿名内部类中不可能有命名构造器（因为这个类本身就没有名字）。但是可以通过成员方法块来实现一个类似的效果。
10.匿名内部类的语法其实就是："创建一个继承自 xxx 的匿名类的对象"。所以本质上匿名类只是一个没有名字的导出类。
11.匿名内部类与正规的继承相比有些受限，因为匿名内部既可以扩展类，也可以实现接口，但是不能两者兼备。而且如果实现接口，也只能实现一个接口。
12.如果不需要让内部类对象与其外围类对象之间有联系，那么可以将内部类声明为 static 的。这通常被称为嵌套类。
13.嵌套类意味着：
 - 要创建嵌套类的对象，并不需要其外围类的对象。
 - 不能从嵌套类的对象中访问非静态的外围类对象。
14.嵌套类与普通内部类还有一个区别。普通内部类的方法和字段，只能放在类的外部层次上，所以普通的内部类不能有 static 数据和 static 字段，也不
能包含嵌套类。但是嵌套类可以包含所有这些东西。
15.接口中的也可以声明内部类，但是接口中的内部类是默认 public static 修饰的，所以接口中的内部类是嵌套类。
16.为什么要有内部类？
 - 普通内部类会隐式持有一个外围类的对象引用，可以认为内部类提供了某种进去其外围类的窗口。
 - 每个内部类都能独立的继承自（接口的）实现，所以无论外围类是否以及继承了某个（接口的）实现，对于内部类都没有影响。
17.如果使用内部类，还可以获得其他一些特性：
 - 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立。
 - 在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或者继承同一个类。
 - 创建内部类对象的时刻并不依赖与外围类对象的创建。
 - 内部类并没有令人迷惑的"is-a"关系；它就是一个独立的实体。
18.应用程序框架就是被设计用以解决某类特定问题的一个类或一组类。
19.使变化的事物与不变的事物相互分离。