第九章 异常

1.第五十七条：只针对异常的情况才使用异常。

顾名思义，异常应该只用于异常的情况：它们永远不应该用于正常的控制流。



2.第五十八条：对可恢复的情况使用受检异常，对变成错误使用运行时异常。

在决定使用受检的异常还是未受检的异常时，主要的原则是：如果期望调用者能够适当的恢复，对于这种情况即应该使用受检的异常。

有两种未受检的可抛出结构：运行时异常和错误。
如果程序抛出未受检的异常或者错误，往往就属于不可恢复的清醒，继续执行下去有害无益。

总而言之，对于可恢复的情况，使用受检的异常；对于程序错误，则使用运行时异常。



3.第五十九条：避免不必要的使用受检的异常。

如果方法抛出一个或者多个受检的异常，调用该方法的代码就必须在一个或者多个 catch 块中处理这些异常，或者它必须声明它抛出这些异常，并让它们传播
出去。无论哪种方法，都给程序员增添了不可忽视的负担。



4.第六十条：优先使用标准的异常。

重用现有的异常有多方面的好处：
 - 其中最主要的好处是，它使你的 API 更容易学习和使用，因为它与程序员已经熟悉的用法是一直的；
 - 第二个好处是，对于用到这些 API 的程序而言，它们的可读性会更好，因为它们不会出现很多程序员不熟悉的异常；
 - 最后一点事，异常类越少，意味着内存印迹就越小，装载这些类的时间开销也越少；

常用的异常：
 - IllegalArgumentException：非 null 的参数值不正确；
 - IllegalStateException：对于方法调用而言，对象状态不合适；
 - NullPointerException：在禁止使用 null 的情况下参数值为 null；
 - IndexOutOfBoundsException：下标参数值越界；
 - ConcurrentModificationException：在禁止并发修改的情况下，检测到对象的并发修改；
 - UnsupportedOperationException：对象不支持用户请求的方法；



5.第六十一条：抛出与抽象相对应的异常。

如果方法抛出的异常与它所执行的任务没有明显的联系，这种情况将会使人不知所措。

更高层的实现应该捕获低层异常，同时抛出可以按照高层抽象进行解释的异常。这种做法被称为异常转译。

尽管异常转译与不加选择的从低层传递异常的做法相比有所改进，但是它也不能被滥用。

异常链对高层和低层异常都提供了最佳的功能：它允许抛出适当的高层异常，同时又能捕获低层的原因进行失败分析。



6.第六十二条：每个方法抛出的异常都要有文档。

描述一个方法所抛出的异常，是正确使用这个方法时所需要文档的重要组成部分。

始终要单独的声明受检的异常，并利用 Javadoc 的 @throws 标记，准确的记录下抛出每个异常的条件。

对于方法可能抛出的未受检异常，如果将这些异常信息很好的组织成列表文档，就可以有效的描述出这个方法会成功执行的前提条件。



7.第六十三条：在细节消息中包含能捕获失败的信息。

为了捕获失败，异常的细节信息应该包含所有"对该异常有贡献"的参数和域的值。



8.第六十四条：努力使失败保持原子性。

一般而言，失败的方法调用应该使对象保持在被调用之前的状态。具有这种属性的方法被成为具有失败原子性。

有几种途径可以实现这种效果：
 - 不可变对象；
 - 对于可变对象，摘自向前检查参数的有效性；
 - 编写一段恢复代码，由它来拦截操作中发生的失败，以及使对象会滚到操作之前的状态上；
 - 在对象的一份临时拷贝上执行操作，当操作完成之后在用临时拷贝中结果代替对象的内容；



9.第六十五条：不要忽略异常。

空的 catch 块会使异常达不到应有的目的，即强迫你处理异常的情况。
每当看到空的 catch 块时，应该警钟长鸣。至少，catch 块中也应该包含一条说明，解释为什么可以忽略这个异常。


