第十五章 泛型

1.在面向对象编程语言中，多态算是一种泛化机制。例如，你可以将方法的参数类型设为基类，那么该方法就可以接受从这个基类中导出的任何类作为参数。
2.理解了边界所在，你才能成为编程高手。因为只有知道了某个技术不能做到什么，你才能更好的做到所能做的。
3.Java 泛型的一个局限性：基本类型无法作为类型参数。不过 Java 5 具备了自动打包和自动拆包的功能，可以很方便的在基本类型和其相应的包装类型之间
进行转换。
4.是否拥有泛型方法，与其所在的类是否是泛型没有关系。因此，泛型方法是的该方法独立于类而产生变化。
5.注意，当使用泛型类时，必须在创建对象的时候指定类型参数的值，而使用泛型方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型。
这称为类型参数推断。因此，我们可以像调用普通方法一样调用泛型方法，而且就好像其被无限重载过。
6.泛型还可以应用于内部类以及匿名内部类。
7.在泛型代码内部，无法获得任何有关泛型参数类型的信息。
8.Java 泛型是使用擦除来实现的，这意味着当你在使用泛型时，任何具体的类型信息都被擦除了。除了，你唯一知道的就是你在使用一个对象。因此 List<String>
和 List<Integer> 在运行时事实上时相同的类型。这两种形式都被擦除成它们的"原生"类型，即 List。
9.如果泛型变量想要调用特定的方法，那么就必须使用到协助泛型类，给定泛型边界，已告知此编译器只能接受遵循这个边界的类型。
例如：
    想要让泛型变量 T t; 调用 HasF 的 f()，那么 t 的泛型类型必须是 <T extends HasF> 而不只是 <T>。
    边界 <T extends HasF> 声明 T 必须具有类型 HasF 或者从 HasF 导出的类型。
如果这么看，那么默认情况下，<T> 相当于 <T extends Object>。
10.<T extends x>，这里 extends 后面可以是接口也可以是类。
11.泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型都被查处，替换为它们的非泛型上界。例如，诸如 List<T> 这样的类型注解将被
擦除为 List，而普通的类型变量在为指定边界的情况下，将被擦除为 Object。
12.擦除的核心动机是它使得泛化的客户端可以用非泛化的类库来使用，反之亦然，这经常被成为"迁移兼容性" 。主要是还是由于泛型在 Java 中出现的比较
晚，所以要做兼容。因此 Java 泛型不仅必须支持向后兼容性，即先后的代码的类文件仍旧合法，并且继续保持其之前的含义；而且还要支持迁移兼容性，使得
类库按照它们自己的步调变为泛型的，并且当某个类库变为泛型后，不会破坏依赖于它的代码和程序。所以，Java 设计者们和各个团队认为擦除是唯一可行的
解决方案。
13.擦除的代价是显著的。泛型不能用于显式的引用运行时类型的操作之中。
14.当你希望将类型参数不要仅仅当作 Object 处理时，就需要付出额外的努力来管理边界。
15.就像 <T extends HasF & A & Comparable>，泛型中 extends 如果后面有多个边界，那么类必须在 extends 后面，而且只能存在一个类，可以有
多个接口，并且其余的用 & 分隔开。
16.通配符的使用：<? extends A> 表示任何扩展自 A 的对象，取决于你是否想要从泛型参数中返回类型确定的返回值。
超类型通配符的使用：<? super A> 表示是由某个特定类的任何基类来界定的，取决于你是否想要像泛型参数传递类型确定的参数。
无界通配符的使用：<?> 表示任何事物。不过它是在声明："我想用 Java 的泛型来编写这段代码，我在这里并不要用原声类型，但是在当前这种情况下，泛型
参数可以持有任何类型。"
17.使用 Java 泛型时会出现的一些问题：
 - 任何基本类型都不能作为类型参数，只能使用其包装类。
 - 一个类不能实现同一个泛型接口的两种变体。
 - 使用带有泛型参数的转型或 instanceof 不会有任何效果。
 - 重载。由于擦除原因，重载方法将产生相同的类型签名。所以比如 List<T> 和 List<W> 分别作为参数不算重载。
 - 基类劫持了接口。比如书中基类和子类都实现了 Comparable 的问题。使用泛型参数只能是同一个，不能不同。
18.自限定类型：class A<T extends A<T>> 它可以保证类型参数必须和正在被定义的类相同。自限定只能强制作用于继承关系。
自限定的价值在于它们可以产生协变参数类型————方法参数类型会随子类而变化。导出类方法应该能够返回比它覆盖的基类更具体的类型。
19.装饰器模式使用分层对象来动态透明的向当个对象中添加责任。
20.动态型语言：所有的类型检查都发生在运行时；静态型语言：类型检查发生在编译期。
21.对缺乏潜在类型机制的补偿：
 - 通过反射。
 - 通过将一个方法应用于序列。
 - 通过用适配器反正潜在类型机制。
