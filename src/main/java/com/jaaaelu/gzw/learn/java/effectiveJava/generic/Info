第五章 泛型

1.第二十三条：请不要在新代码中使用原声态类型。

泛型类和接口统称为泛型。

每一个泛型都定义了一个原生态类型，既不带任何实际类型参数的泛型名称。例如，List<E> 相对应的原生态类型是 List。
原生态类型就像从类型声明中删除了所有类型信息一样。

如果使用原生态类型，就是掉了泛型在安全性和表述性方面的所有优势。

List 和 List<Object> 的区别：不严格的说，前者逃避了泛型检查，后者则明确告知编译器，它能够支持任意类型对象；虽然你可以将 List<String> 传
递给 List 的参数，但是不能将它传给类型为 List<Object> 的参数。
泛型有子类型化的规则，List<String> 是原生态 List 的一个子类型，而不是参数化类型 List<Object> 的只类型。

使用原生态类型其实不安全的，因此 Java 提供了一种安全的替代方法，乘坐无限制的通配符类型。如果要是用泛型，但是不确定或者不关心实际的参数类型，
就可以使用一个问号代替。例如，泛型 Set<E> 的无限制通配符类型为 Set<?>（读作"某个类型的集合"）。

例外（都源于"泛型类型可以在幸运石被擦除"）：
 - class 中无法使用泛型类型；
 - instanceof 关键字中无法使用泛型类型；

为什么还会提供原生态类型？原生态类型只是为了与引入泛型之前的遗留代码进行兼容和互用而提供的。

术语学习：
 - 参数化的类型：List<String>；
 - 实际类型参数：String；
 - 泛型：List<E>；
 - 无限制通配符类型：List<?>；
 - 原生态类型：List；
 - 有限制类型参数：<E extends Number>；
 - 递归类型限制：<T extends Comparable<T>>；
 - 有限制通配符类型：List<? extends Number>；
 - 泛型方法：(static) <E> List<E> asList(E[] a)；
 - 泛型令牌：String.class；



2.第二十四条：消除非受检警告。

要尽可能地消除每一个非受检警告。如果消除了所有警告，就可以确保代码是类型安全的。

如果无法消除警告，同时可以证明引起警告的代码是类型安全的，（只有在这种情况下才）可以用一个 @SuppressWarnings("unchecked") 注解来禁止这条
警告。
如果在禁止警告之前没有先证实代码是类型安全的，那就只是给自己一种错误的安全感而已。

应该始终在尽可能小的范围中使用 SuppressWarnings 注解。
永远不要在整个类上使用 SuppressWarnings，这么做可能会掩盖了重要的警告。

每当使用 SuppressWarnings("unchecked") 注解时，都要添加一条注释，说明为什么这么做是安全的。




3.第二十五条：列表优先于数组。

数组和泛型相比，有两个重要的不同点：
 - 数组是协变的，表示如果 Sub 是 Super 的子类型，那么数组类型 Sub[] 就是 Super[] 的子类型。
 相反泛型则是不可变的，对于任意两个不同类型的 Type1 和 Type2，List<Type1> 既不是 List<Type2> 的子类型，也不是 List<Type2> 的超类型。
    例：Object[] oas = new Long[1]; 是可行的。
    但：List<Object> ols = new ArrayList<Long>(); 是不可行的。
 - 数组是具体化的，因此数组会在运行时才知道并检查它们的元素类型约束。
 相比之下，泛型这是通过擦出来实现的，因此泛型只在编译时强化它们的类型信息，并在运行时丢弃（或者擦除）它们的元素类型信息。

从技术的角度来说，像 E、List<E> 和 List<String> 这样的类型应称作不可具体化的类型。不可具体化的类型是指其在运行时表示法包含的信息比它编译
时表示法包含的信息更少的类型。唯一可具体化的参数类型是无限制的通配符类型。

泛型数组是无法创建的，因为它不是类型安全的。

当你得到泛型数组创建错误时，最好的解决办法通常是优先使用集合类型 List<E>，而不是数组类型 E[]。

数组是协变且可以具体化的；泛型是不可变且可以被擦除的。因此，数组提供了运行时的类型安全，但是没有编译时的类型安全，反之，对于泛型也是一样。



4.第二十六条：优先考虑泛型。

类型参数列表（<E extends Number>）要求实际的类型参数 E 必须是 Number 的一个子类型。



5.第二十七条：优先考虑泛型方法。

静态工具方法尤其适合泛型化。

类型限制 <T extends Comparable<T>>，可以读作"针对可以与自身进行比较的每个类型 T"。



6.第二十八条：利用有限制通配符来提升 API 的灵活性。

Iterable<? extends E> 表示的是"E 的某个子类型的 Iterable 接口"。

Collection<? super E> 表示的是"E 的某种超类的集合"。

换句话说，如果一个参数化类型表示一个 T 生产者，就使用 <? extends T>；如果它表示一个 T 消费者，就使用 <? super T>。
书中的 Stack 示例中，pushAll 的 src 参数产生 E 实例供 Stack 使用，因此 src 相应的类型为 Iterable<? extends E>；popAll 的 dst 参数
通过 Stack 消费 E 实例，因此 dst 的相应类型为 Collection<? super E>。
pushAll:
    public void pushAll(Iterable<? extends E>) {
        for (E e : src) {
            push(e);
        }
    }
popAll:
    public void popAll(Collection<? super E>) {
        while(!isEmpty()) {
            dst.add(pop());
        }
    }

不要用通配符类型作为返回类型。



7.第二十九：优先考虑类型安全的异构容器。

没看懂。。。